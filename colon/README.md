# Colon Interpreter

Добро пожаловать в **Colon Interpreter** — простой интерпретатор языка, похожего на Forth, реализованный на Haskell. Этот проект предоставляет основные функциональные возможности для выполнения арифметических операций, управления стеком, работы с памятью, а также поддерживает пользовательские определения слов, условные операторы и циклы.

## Содержание

1. [Арифметика](#арифметика)
2. [Объявление новых слов](#объявление-новых-слов)
3. [Комментарии](#комментарии)
4. [Манипулирование стеком](#манипулирование-стеком)
5. [Ввод-вывод](#ввод-вывод)
6. [Булевские значения](#булевские-значения)
7. [Условный оператор](#условный-оператор)
8. [Циклы](#циклы)
9. [Доступ к памяти](#доступ-к-памяти)

---

## Арифметика

### Функциональность

Поддержка базовых арифметических операций, включая сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`) и остаток от деления (`MOD`). Эти операции позволяют выполнять математические вычисления с целыми числами, манипулируя значениями на стеке.

### Реализация

Арифметические операции реализованы как функции, которые берут верхние элементы стека, выполняют соответствующую операцию и помещают результат обратно на стек. Например, операция сложения (`+`) извлекает два верхних значения, складывает их и помещает сумму обратно на стек.

### Взаимодействие

Арифметические команды взаимодействуют напрямую со стеком, обеспечивая манипуляцию числами и результатами операций. Они могут быть использованы как в простых выражениях, так и в составе более сложных команд и пользовательских слов.

### Опыт

При реализации арифметических операций я углубился в управление стеком и обработку ошибок, таких как деление на ноль. Это позволило мне лучше понять функциональное программирование и работу с монадами в Haskell.

---

## Объявление новых слов

### Функциональность

Возможность определять новые слова (команды) с помощью синтаксиса `: <имя> <определение> ;`. Это позволяет расширять функциональность интерпретатора, создавая пользовательские команды, которые могут включать последовательности существующих команд.

### Реализация

Определение новых слов обрабатывается при встрече команды `:`. Интерпретатор собирает все токены до `;` и добавляет новое слово в словарь (`Dictionary`) с его определением. При вызове такого слова интерпретатор выполняет последовательность команд, определённых пользователем.

### Взаимодействие

Пользовательские слова могут включать любые существующие команды и другие пользовательские слова, обеспечивая гибкость и расширяемость языка. Они интегрируются в основной цикл обработки токенов и управляются словарём интерпретатора.

### Опыт

Реализация возможности определения новых слов потребовала продуманного управления словарём и рекурсивной обработки токенов. Это значительно расширило возможности интерпретатора и позволило лучше понять механизмы расширяемости в языке.

---

## Комментарии

### Функциональность

Поддержка комментариев, заключённых в круглые скобки `(` и `)`. Всё, что находится внутри комментария, игнорируется интерпретатором, что позволяет добавлять пояснения к коду без влияния на его выполнение.

### Реализация

Функция `removeComments` обрабатывает входную строку, удаляя все символы, находящиеся между открывающей и закрывающей скобкой. Это реализовано с помощью рекурсивной обработки строки и отслеживания уровня вложенности комментариев.

### Взаимодействие

Комментарии не влияют на стек или словарь и служат исключительно для улучшения читаемости кода. Они могут быть использованы в любом месте программы для добавления пояснений или временного исключения кода из выполнения.

### Опыт

Реализация комментариев помогла мне разобраться с обработкой строк и управлением состоянием интерпретатора. Это также улучшило понимание работы с рекурсией и обработки вложенных структур.

---

## Манипулирование стеком

### Функциональность

Поддержка команд для управления стеком, включая `DUP` (дублирование верхнего элемента), `DROP` (удаление верхнего элемента), `SWAP` (замена двух верхних элементов), `OVER` (копирование второго элемента на верх стека) и `ROT` (вращение трёх верхних элементов). Эти команды позволяют эффективно управлять данными на стеке.

### Реализация

Каждая команда стека реализована как отдельная функция, которая принимает текущий стек, выполняет соответствующую операцию и возвращает обновлённый стек. Например, `DUP` извлекает верхний элемент и добавляет его снова на стек.

### Взаимодействие

Команды стека могут использоваться как самостоятельно, так и в комбинации с другими командами и пользовательскими словами. Они обеспечивают базовые операции по манипуляции данными, необходимые для выполнения более сложных задач.

### Опыт

Работа с манипулированием стеком укрепила мои знания о структурах данных и их обработке в функциональном программировании. Это также улучшило понимание работы с монадами и состоянием в Haskell.

---

## Ввод-вывод

### Функциональность

Поддержка команд для взаимодействия с пользователем, включая `.` (вывод верхнего элемента стека), `CR` (переход на новую строку), `EMIT` (вывод символа по ASCII-коду), `KEY` (чтение символа с ввода) и `."` (вывод строки). Эти команды позволяют интерпретатору взаимодействовать с пользователем через консоль.

### Реализация

Команды ввода-вывода используют функции `liftIO` для выполнения операций ввода и вывода в контексте монады `StateT`. Например, команда `.` извлекает верхний элемент стека и выводит его, затем удаляет из стека.

### Взаимодействие

Команды ввода-вывода работают совместно с другими командами интерпретатора, позволяя пользователю получать результаты вычислений и вводить данные в программу. Они обеспечивают необходимую интерактивность и обратную связь.

### Опыт

Реализация команд ввода-вывода потребовала углубленного понимания работы с монадами в Haskell и взаимодействия с внешним миром через IO. Это расширило мои навыки работы с функциональными языками программирования.

---

## Булевские значения

### Функциональность

Поддержка булевских операций, включая `AND` (логическое И), `OR` (логическое ИЛИ) и `INVERT` (логическое НЕ). Эти операции позволяют работать с логическими значениями, представляя истинные (`1`) и ложные (`0`) состояния.

### Реализация

Булевские операции реализованы как арифметические функции, которые обрабатывают значения на стеке в соответствии с логическими правилами. Например, `AND` выполняет побитовое И двух верхних элементов стека.

### Взаимодействие

Булевские операции могут использоваться в условных операторах и циклах для контроля потока выполнения программы. Они также могут быть частью пользовательских слов и комбинироваться с другими арифметическими и логическими командами.

### Опыт

Работа с булевскими значениями углубила мои знания о битовых операциях и логике в программировании. Это также помогло мне лучше понять взаимодействие различных типов данных в функциональном языке.

---

## Условный оператор

### Функциональность

Поддержка условных операторов `IF ... THEN` и `IF ... ELSE ... THEN`. Эти конструкции позволяют выполнять команды в зависимости от условий, представленных булевыми значениями на стеке.

### Реализация

Условные операторы реализованы путем проверки верхнего элемента стека. Если условие истинно (`1`), выполняется первая ветка команд, иначе — вторая (при наличии `ELSE`). Команды `IF` и `ELSE` обрабатываются путем разделения токенов и рекурсивного выполнения соответствующих секций.

### Взаимодействие

Условные операторы взаимодействуют с булевскими значениями и позволяют создавать более сложные логические конструкции и контролировать поток выполнения программы. Они могут быть использованы внутри циклов и пользовательских слов для создания гибких программ.

### Опыт

Реализация условных операторов потребовала продуманной обработки токенов и управления состоянием интерпретатора. Это улучшило мои навыки в управлении потоком выполнения и работе с рекурсией в Haskell.

---

## Циклы

### Функциональность

Поддержка циклов `DO ... LOOP`, позволяющих выполнять блок команд определённое количество раз. Также реализована команда `I` для доступа к текущему индексу цикла.

### Реализация

Циклы реализованы путем извлечения начального и конечного значений из стека, генерации последовательности индексов и выполнения тела цикла для каждого индекса. Команда `I` извлекает текущий индекс из стека циклов и помещает его на основной стек.

### Взаимодействие

Циклы позволяют выполнять повторяющиеся операции и работать с индексами, что важно для итеративных задач. Они могут быть использованы совместно с условными операторами и пользовательскими словами для создания сложных программных структур.

### Опыт

Работа с циклами улучшила мое понимание итеративных процессов и управления состоянием в функциональном программировании. Это также позволило мне углубиться в работу с монадами и стековыми структурами данных.

---

## Доступ к памяти

### Функциональность

Поддержка доступа к памяти через переменные и константы. Команды `VARIABLE`, `CONSTANT`, `!` (установка значения переменной), `@` (получение значения переменной) и `?` (печать значения переменной).

### Реализация

Переменные и константы управляются через словарь (`Dictionary`), который связывает имена с адресами или значениями. Команда `VARIABLE` выделяет место в памяти для переменной, а `CONSTANT` связывает имя с фиксированным значением. Операции `!` и `@` позволяют устанавливать и получать значения переменных соответственно.

### Взаимодействие

Доступ к памяти позволяет сохранять и извлекать данные между различными частями программы. Это обеспечивает возможность работы с состоянием и данными, необходимыми для выполнения более сложных задач.

### Опыт

Реализация доступа к памяти потребовала тщательного управления адресами и значениями, а также обеспечения безопасности и корректности операций. Это улучшило мои навыки работы с состоянием и памятью в Haskell.

---

## BEGIN ... UNTIL

### Функциональность

Поддержка цикла `BEGIN ... UNTIL`, который выполняет блок команд **повторно**, пока значение на вершине стека не окажется отличным от нуля. Это похоже на классический цикл *repeat-until*.

### Реализация

1. Считываются команды между `BEGIN` и `UNTIL`.
2. В цикле выполняется тело (команды между `BEGIN` и `UNTIL`).
3. После каждого выполнения проверяется значение на вершине стека:
   - Если оно отлично от нуля, цикл завершается;
   - Иначе повторяется выполнение тела.

### Взаимодействие

Данный цикл позволяет реализовывать конструкции, где нужно повторять действия до достижения некоторого условия. В сочетании с условными операторами и пользовательскими словами это даёт богатые возможности для создания гибких и лаконичных решений итерационных задач.

### Опыт

При реализации цикла `BEGIN ... UNTIL` особенно полезно было разобраться в механизмах организации рекурсивных вызовов и корректного чтения/записи вершины стека внутри цикла. Это позволило глубже понять, как монада состояния может управлять пошаговым выполнением кода.

---

## Проверка комментариев про стек

### Функциональность

В языке поддерживается **статическая проверка** комментариев вида `( a b -- c d )`, которые описывают, **сколько** элементов снимается со стека и **сколько** возвращается при выполнении слова. Это помогает находить несоответствия между объявленным и фактическим стек-эффектом.

### Реализация

1. При определении нового слова `: WORD ... ;` анализируются токены.
2. Если в списке токенов встречается комментарий вида `( ... -- ... )`, парсится количество входных и выходных элементов.
3. Выполняется упрощённый статический анализ всех операций, чтобы вычислить их «нетто-эффект».
4. Сравнивается результат анализа и объявленный комментарий:
   - При включённом `strictMode` — несоответствие приводит к ошибке;
   - При выключённом `strictMode` — несоответствие лишь предупреждается.

### Взаимодействие

Такая проверка облегчает отладку программ, написанных в стиле Forth, поскольку при ошибках в логике (неверном количестве снимаемых/кладёмых элементов) интерпретатор может сразу сигнализировать об этом. Это повышает надёжность кода и упрощает командную работу над проектом.

### Опыт

Реализация проверки комментариев укрепила понимание концепции «стек-эффекта» и показала, как статический анализ может выявлять ошибки, не дожидаясь запуска кода. Кроме того, стало понятно, как эффективно совмещать функциональную и стековую парадигмы.

---

## Массивы

### Функциональность

Позволяет создавать массивы и обращаться к их элементам в стиле Forth с помощью слов `CREATE`, `CELLS`, `ALLOT`. После объявления массива можно использовать обычные операции `!`, `@`, `+!`, `-!`, `*!`, `/!`, `MOD!` для работы с элементами.

### Реализация

1. **CREATE имя** — регистрирует базовый адрес массива (получаемый из `nextAddress`) в словаре как «константу».
2. **CELLS** — умножает верхнее целое число на размер ячейки (упрощённо 1).
3. **ALLOT** — увеличивает `nextAddress` на заданное число ячеек и **инициализирует** их в памяти (например, записывает нули).
4. При доступе к элементу массива делается: `имя-массива N CELLS +`, где `N` — индекс, а результат будет адрес конкретной ячейки. Слова `! @ +! -! *! /! MOD!` работают с этим адресом, записывая/читая целые значения.

### Взаимодействие

Массивы позволяют хранить и обрабатывать наборы однотипных данных. В сочетании с циклами и условными операторами упрощают реализацию множества алгоритмов. Ключевую роль играет корректное вычисление адресов (с использованием `CELLS +`) и заполнение памяти при `ALLOT`.

### Опыт

При реализации массивов было важно удостовериться, что выделяемые адреса действительно регистрируются в таблице памяти. Ошибки с незаполненным диапазоном приводили к сообщениям «Недопустимый адрес переменной», что помогло глубже изучить управление состоянием памяти.

---

## Арифметические операции над числами с плавающей точкой

### Функциональность

Данный функционал позволяет хранить на стеке как целые (`I Int`), так и вещественные (`F Double`) числа. Арифметические операции (`+`, `-`, `*`, `/`, `MOD`) учитывают типы операндов и возвращают результат в зависимости от того, целые они или вещественные.

### Реализация

1. **Расширение типа Value**:
   ```haskell
   data Value = I Int | F Double

---

## CASE ... OF ... ENDOF ... ENDCASE

### Функциональность

Позволяет в стиле Forth выполнять разные действия в зависимости от значения некоторого «управляющего» элемента на стеке. Команда `CASE` снимает элемент (далее — `switchValue`) и сравнивает его с несколькими «кандидатами» в ветках `OF ... ENDOF`. Если одна из веток совпадает, её код выполняется, остальные пропускаются. Если ни одна ветка не сработала, исполняется «дефолтный» код перед `ENDCASE`.

### Реализация

1. **CASE** — снимает `switchValue` со стека и начинает разбор ветвей.
2. **OF** `expr` **ENDOF** — каждая ветка:
   1. Выполняет последовательность слов `expr`, результат (candidate) сравнивается со `switchValue`.
   2. Если равны, оба значения убираются (candidate и `switchValue`), выполняется тело ветки до `ENDOF`, и делается переход за весь `CASE`.
   3. Если не равны, убирается только candidate, а выполнение пропускает тело ветки и переходит к следующей.
3. **Дефолтный код** — часть, расположенная сразу после последней ветки `OF ... ENDOF` и до `ENDCASE`. Исполняется, если ни одна ветка не совпала.
4. **ENDCASE** — завершение конструкции, выбрасывает остатки и продолжает дальнейшее выполнение программы.

### Взаимодействие

Конструкция `CASE` может содержать любую логику в ветках `OF ... ENDOF`, включая вызовы пользовательских слов, арифметику, циклы и так далее. При этом она тесно сочетается с другими элементами языка (например, в каждой ветке можно использовать слова `IF`, `DO`, массивы и т.п.). Ветка, которая «сработала», исключает выполнение остальных ветвей, как и в классическом switch-case в языках C-подобного семейства.

### Опыт

Реализация `CASE` углубляет понимание механизма работы со стеком при условных переходах: важно корректно снимать `switchValue`, восстанавливать его на стеке при несовпадении, пропускать ветви и переходить к «дефолту» при необходимости. Также это позволяет создавать более гибкую логику выбора (multiple-choice), не ограничиваясь простыми `IF ... ELSE`. В процессе были отлажены детали пропуска веток, чтобы избежать лишних команд и исключить конфликты со словами `OF`, `ENDOF`, `ENDCASE`.

---


## Заключение

**Colon Interpreter** предоставляет базовые и расширенные возможности для выполнения программ, похожих на Forth, с поддержкой арифметики, управления стеком, доступа к памяти, условных операторов и циклов. Реализация этого проекта позволила мне углубиться в функциональное программирование на Haskell, понять работу с монадами, состоянием и рекурсией, а также улучшить навыки управления сложными структурами данных и контролем потока выполнения программ.

---

## Установка и Запуск

### Предварительные требования

- **Haskell** (GHC) установлен на вашей системе.
- **Cabal** или **Stack** для управления зависимостями и сборкой проекта.

### Установка зависимостей

1. **Cabal:**

   ```bash
   cabal update
   cabal build
   
### Выбранный функционал на 2 этап:
- ~~Цикл BEGIN UNTIL~~
- Работа с графикой GRAPHICS + LAST-KEY
- ~~Проверка комментариев про стек~~
- ~~Массивы~~
- REPL с readline
- ~~Конструкция case of endof endcase~~
- ~~Арифмитические операции над числами с плавающей запятой~~
