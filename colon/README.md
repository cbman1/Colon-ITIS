# Colon Interpreter

Добро пожаловать в **Colon Interpreter** — простой интерпретатор языка, похожего на Forth, реализованный на Haskell. Этот проект предоставляет основные функциональные возможности для выполнения арифметических операций, управления стеком, работы с памятью, а также поддерживает пользовательские определения слов, условные операторы и циклы.

## Содержание

1. [Арифметика](#арифметика)
2. [Объявление новых слов](#объявление-новых-слов)
3. [Комментарии](#комментарии)
4. [Манипулирование стеком](#манипулирование-стеком)
5. [Ввод-вывод](#ввод-вывод)
6. [Булевские значения](#булевские-значения)
7. [Условный оператор](#условный-оператор)
8. [Циклы](#циклы)
9. [Доступ к памяти](#доступ-к-памяти)

---

## Арифметика

### Функциональность

Поддержка базовых арифметических операций, включая сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`) и остаток от деления (`MOD`). Эти операции позволяют выполнять математические вычисления с целыми числами, манипулируя значениями на стеке.

### Реализация

Арифметические операции реализованы как функции, которые берут верхние элементы стека, выполняют соответствующую операцию и помещают результат обратно на стек. Например, операция сложения (`+`) извлекает два верхних значения, складывает их и помещает сумму обратно на стек.

### Взаимодействие

Арифметические команды взаимодействуют напрямую со стеком, обеспечивая манипуляцию числами и результатами операций. Они могут быть использованы как в простых выражениях, так и в составе более сложных команд и пользовательских слов.

### Опыт

При реализации арифметических операций я углубился в управление стеком и обработку ошибок, таких как деление на ноль. Это позволило мне лучше понять функциональное программирование и работу с монадами в Haskell.

---

## Объявление новых слов

### Функциональность

Возможность определять новые слова (команды) с помощью синтаксиса `: <имя> <определение> ;`. Это позволяет расширять функциональность интерпретатора, создавая пользовательские команды, которые могут включать последовательности существующих команд.

### Реализация

Определение новых слов обрабатывается при встрече команды `:`. Интерпретатор собирает все токены до `;` и добавляет новое слово в словарь (`Dictionary`) с его определением. При вызове такого слова интерпретатор выполняет последовательность команд, определённых пользователем.

### Взаимодействие

Пользовательские слова могут включать любые существующие команды и другие пользовательские слова, обеспечивая гибкость и расширяемость языка. Они интегрируются в основной цикл обработки токенов и управляются словарём интерпретатора.

### Опыт

Реализация возможности определения новых слов потребовала продуманного управления словарём и рекурсивной обработки токенов. Это значительно расширило возможности интерпретатора и позволило лучше понять механизмы расширяемости в языке.

---

## Комментарии

### Функциональность

Поддержка комментариев, заключённых в круглые скобки `(` и `)`. Всё, что находится внутри комментария, игнорируется интерпретатором, что позволяет добавлять пояснения к коду без влияния на его выполнение.

### Реализация

Функция `removeComments` обрабатывает входную строку, удаляя все символы, находящиеся между открывающей и закрывающей скобкой. Это реализовано с помощью рекурсивной обработки строки и отслеживания уровня вложенности комментариев.

### Взаимодействие

Комментарии не влияют на стек или словарь и служат исключительно для улучшения читаемости кода. Они могут быть использованы в любом месте программы для добавления пояснений или временного исключения кода из выполнения.

### Опыт

Реализация комментариев помогла мне разобраться с обработкой строк и управлением состоянием интерпретатора. Это также улучшило понимание работы с рекурсией и обработки вложенных структур.

---

## Манипулирование стеком

### Функциональность

Поддержка команд для управления стеком, включая `DUP` (дублирование верхнего элемента), `DROP` (удаление верхнего элемента), `SWAP` (замена двух верхних элементов), `OVER` (копирование второго элемента на верх стека) и `ROT` (вращение трёх верхних элементов). Эти команды позволяют эффективно управлять данными на стеке.

### Реализация

Каждая команда стека реализована как отдельная функция, которая принимает текущий стек, выполняет соответствующую операцию и возвращает обновлённый стек. Например, `DUP` извлекает верхний элемент и добавляет его снова на стек.

### Взаимодействие

Команды стека могут использоваться как самостоятельно, так и в комбинации с другими командами и пользовательскими словами. Они обеспечивают базовые операции по манипуляции данными, необходимые для выполнения более сложных задач.

### Опыт

Работа с манипулированием стеком укрепила мои знания о структурах данных и их обработке в функциональном программировании. Это также улучшило понимание работы с монадами и состоянием в Haskell.

---

## Ввод-вывод

### Функциональность

Поддержка команд для взаимодействия с пользователем, включая `.` (вывод верхнего элемента стека), `CR` (переход на новую строку), `EMIT` (вывод символа по ASCII-коду), `KEY` (чтение символа с ввода) и `."` (вывод строки). Эти команды позволяют интерпретатору взаимодействовать с пользователем через консоль.

### Реализация

Команды ввода-вывода используют функции `liftIO` для выполнения операций ввода и вывода в контексте монады `StateT`. Например, команда `.` извлекает верхний элемент стека и выводит его, затем удаляет из стека.

### Взаимодействие

Команды ввода-вывода работают совместно с другими командами интерпретатора, позволяя пользователю получать результаты вычислений и вводить данные в программу. Они обеспечивают необходимую интерактивность и обратную связь.

### Опыт

Реализация команд ввода-вывода потребовала углубленного понимания работы с монадами в Haskell и взаимодействия с внешним миром через IO. Это расширило мои навыки работы с функциональными языками программирования.

---

## Булевские значения

### Функциональность

Поддержка булевских операций, включая `AND` (логическое И), `OR` (логическое ИЛИ) и `INVERT` (логическое НЕ). Эти операции позволяют работать с логическими значениями, представляя истинные (`1`) и ложные (`0`) состояния.

### Реализация

Булевские операции реализованы как арифметические функции, которые обрабатывают значения на стеке в соответствии с логическими правилами. Например, `AND` выполняет побитовое И двух верхних элементов стека.

### Взаимодействие

Булевские операции могут использоваться в условных операторах и циклах для контроля потока выполнения программы. Они также могут быть частью пользовательских слов и комбинироваться с другими арифметическими и логическими командами.

### Опыт

Работа с булевскими значениями углубила мои знания о битовых операциях и логике в программировании. Это также помогло мне лучше понять взаимодействие различных типов данных в функциональном языке.

---

## Условный оператор

### Функциональность

Поддержка условных операторов `IF ... THEN` и `IF ... ELSE ... THEN`. Эти конструкции позволяют выполнять команды в зависимости от условий, представленных булевыми значениями на стеке.

### Реализация

Условные операторы реализованы путем проверки верхнего элемента стека. Если условие истинно (`1`), выполняется первая ветка команд, иначе — вторая (при наличии `ELSE`). Команды `IF` и `ELSE` обрабатываются путем разделения токенов и рекурсивного выполнения соответствующих секций.

### Взаимодействие

Условные операторы взаимодействуют с булевскими значениями и позволяют создавать более сложные логические конструкции и контролировать поток выполнения программы. Они могут быть использованы внутри циклов и пользовательских слов для создания гибких программ.

### Опыт

Реализация условных операторов потребовала продуманной обработки токенов и управления состоянием интерпретатора. Это улучшило мои навыки в управлении потоком выполнения и работе с рекурсией в Haskell.

---

## Циклы

### Функциональность

Поддержка циклов `DO ... LOOP`, позволяющих выполнять блок команд определённое количество раз. Также реализована команда `I` для доступа к текущему индексу цикла.

### Реализация

Циклы реализованы путем извлечения начального и конечного значений из стека, генерации последовательности индексов и выполнения тела цикла для каждого индекса. Команда `I` извлекает текущий индекс из стека циклов и помещает его на основной стек.

### Взаимодействие

Циклы позволяют выполнять повторяющиеся операции и работать с индексами, что важно для итеративных задач. Они могут быть использованы совместно с условными операторами и пользовательскими словами для создания сложных программных структур.

### Опыт

Работа с циклами улучшила мое понимание итеративных процессов и управления состоянием в функциональном программировании. Это также позволило мне углубиться в работу с монадами и стековыми структурами данных.

---

## Доступ к памяти

### Функциональность

Поддержка доступа к памяти через переменные и константы. Команды `VARIABLE`, `CONSTANT`, `!` (установка значения переменной), `@` (получение значения переменной) и `?` (печать значения переменной).

### Реализация

Переменные и константы управляются через словарь (`Dictionary`), который связывает имена с адресами или значениями. Команда `VARIABLE` выделяет место в памяти для переменной, а `CONSTANT` связывает имя с фиксированным значением. Операции `!` и `@` позволяют устанавливать и получать значения переменных соответственно.

### Взаимодействие

Доступ к памяти позволяет сохранять и извлекать данные между различными частями программы. Это обеспечивает возможность работы с состоянием и данными, необходимыми для выполнения более сложных задач.

### Опыт

Реализация доступа к памяти потребовала тщательного управления адресами и значениями, а также обеспечения безопасности и корректности операций. Это улучшило мои навыки работы с состоянием и памятью в Haskell.

---

## Заключение

**Colon Interpreter** предоставляет базовые и расширенные возможности для выполнения программ, похожих на Forth, с поддержкой арифметики, управления стеком, доступа к памяти, условных операторов и циклов. Реализация этого проекта позволила мне углубиться в функциональное программирование на Haskell, понять работу с монадами, состоянием и рекурсией, а также улучшить навыки управления сложными структурами данных и контролем потока выполнения программ.

---

## Установка и Запуск

### Предварительные требования

- **Haskell** (GHC) установлен на вашей системе.
- **Cabal** или **Stack** для управления зависимостями и сборкой проекта.

### Установка зависимостей

1. **Cabal:**

   ```bash
   cabal update
   cabal build
